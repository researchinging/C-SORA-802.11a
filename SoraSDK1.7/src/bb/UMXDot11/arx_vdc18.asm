; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??$NeedNewDescriptor@$0BC@@@YA_NH@Z		; NeedNewDescriptor<18>
PUBLIC	??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z ; VitDesCRC<18,3,72,72,VB<96,128> >
	ORG $+1056736
rgbLongPrePositive DB 00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
gAGCLut	DD	0fffffff9H
	DD	0fffffffaH
	DD	0fffffffbH
	DD	0fffffffcH
	DD	0fffffffdH
	DD	0fffffffeH
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
; Function compile flags: /Ogtpy
; File c:\sorasdk1.7\src\bb\dot11a\dot11\arx_vdc.h
;	COMDAT ??$NeedNewDescriptor@$0BC@@@YA_NH@Z
_TEXT	SEGMENT
iTrellis$ = 8
??$NeedNewDescriptor@$0BC@@@YA_NH@Z PROC		; NeedNewDescriptor<18>, COMDAT

; 11   : template<> inline bool NeedNewDescriptor<18>(int iTrellis) { return iTrellis == 72 || iTrellis == 144; }

	cmp	ecx, 72					; 00000048H
	je	SHORT $LN3@NeedNewDes
	cmp	ecx, 144				; 00000090H
	je	SHORT $LN3@NeedNewDes
	xor	al, al
	ret	0
$LN3@NeedNewDes:
	mov	al, 1
	ret	0
??$NeedNewDescriptor@$0BC@@@YA_NH@Z ENDP		; NeedNewDescriptor<18>
;	COMDAT pdata
; File c:\sorasdk1.7\inc\crc32.h
pdata	SEGMENT
$pdata$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z DD imagerel $LN3221
	DD	imagerel $LN3221+241
	DD	imagerel $unwind$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z DD imagerel $LN3221+241
	DD	imagerel $LN3221+3037
	DD	imagerel $chain$1$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z DD imagerel $LN3221+3037
	DD	imagerel $LN3221+3063
	DD	imagerel $chain$2$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z DD 021H
	DD	imagerel $LN3221
	DD	imagerel $LN3221+241
	DD	imagerel $unwind$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z DD 041021H
	DD	016e410H
	DD	0156408H
	DD	imagerel $LN3221
	DD	imagerel $LN3221+241
	DD	imagerel $unwind$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z DD 0a2701H
	DD	066827H
	DD	0173411H
	DD	0f00dd211H
	DD	0c009d00bH
	DD	050067007H
; Function compile flags: /Ogtpy
; File c:\sorasdk1.7\src\bb\dot11a\dot11\arx_vdc.h
xdata	ENDS
;	COMDAT ??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z
_TEXT	SEGMENT
uiBitsTotal$1$ = 0
bSeed$ = 4
i_trellis$1$ = 8
uiCrc32Store$ = 8
blkInput$1$ = 16
uiCrc32StorePoint$1$ = 24
pbVitOutput$1$ = 32
blkInputStart$1$ = 40
blksStart$1$ = 48
pTrellis$3$ = 56
fWork$1$ = 64
blksEnd$1$ = 72
pRxContextA$GSCopy$1$ = 80
pRxContextA$ = 160
vb$ = 168
??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z PROC ; VitDesCRC<18,3,72,72,VB<96,128> >, COMDAT

; 191  : {

$LN3221:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 112				; 00000070H

; 192  :     typedef VB::VB_DCBLOCK VB_DCBLOCK;
; 193  : 
; 194  :     // Thread synchronization flag
; 195  :     volatile FLAG& fWork = *pRxContextA->ri_pbWorkIndicator;
; 196  :     
; 197  :     const int TB_PREFIX = 6;
; 198  :     unsigned int uiBitsTotal = MBitRate * 4 * pRxContextA->uiVitSymbolCount;

	mov	eax, DWORD PTR [rcx+772]
	mov	r11, QWORD PTR [rcx+56]

; 199  :     char *pbVitOutput = pRxContextA->VIT_OBUF;
; 200  :     char *pbOutput = pRxContextA->pbVitFrameOutput;

	mov	r15, QWORD PTR [rcx+784]
	movaps	XMMWORD PTR [rsp+96], xmm6
	lea	r8d, DWORD PTR [rax+rax*8]
	lea	rax, QWORD PTR [rcx+2569120]
	mov	r9, rcx
	mov	QWORD PTR pbVitOutput$1$[rsp], rax

; 201  :     unsigned int uiBytesOutput = 0;
; 202  : 
; 203  :     VB_DCBLOCK * const blksStart   = vb.BlocksBegin();
; 204  :     VB_DCBLOCK * const blksEnd     = vb.BlocksEnd();
; 205  :     
; 206  :     unsigned char bSeed;
; 207  :     DWORD uiCrc32 = 0xFFFFFFFF;
; 208  :     DWORD uiCrc32Store;
; 209  :     unsigned int uiCrc32StorePoint = pRxContextA->uiVitFrameLen + 2 - 4;
; 210  : 
; 211  :     VB_DCBLOCK * blkInputStart = blksStart;
; 212  :     char *blkInput = (char *)blkInputStart;
; 213  :     
; 214  :     int i, j;     
; 215  : 
; 216  :     int ocnt = 0; // Counter for the output bits
; 217  : 
; 218  :     // vector128 constants
; 219  :     const vub * const pVITMA = (const vub*) VIT_MA; // Branch Metric A
; 220  :     const vub * const pVITMB = (const vub*) VIT_MB; // Branch Metric B
; 221  : 
; 222  :     const vub ALLINVONE (ALL_INVERSE_ONE);
; 223  : 
; 224  :     unsigned char outchar = 0;    // the output(decoded) char
; 225  :     unsigned char *pVTOutput;
; 226  :     
; 227  :     vub *pTrellis;          // point to trellis
; 228  :     int i_trellis = 0;      // index of trellis
; 229  : 
; 230  :     // for trace back  
; 231  :     vub *pTraceBk;          // trace back pointer in trellis
; 232  :     int i_minpos = 0;       // the minimal path position
; 233  :     int i_tpos   = 0;
; 234  : 
; 235  :     // temporal variables
; 236  :     vub rub0, rub1, rub2, rub3;
; 237  :     vus rus0, rus1, rus2, rus3;
; 238  :     vus rus4, rus5, rus6, rus7;
; 239  : 
; 240  :     // Initialize Trellis
; 241  :     pTrellis = (vub *) pRxContextA->trellisData;

	lea	rbp, QWORD PTR [r9+9120]
	xor	ebx, ebx
	lea	rax, QWORD PTR [rdx+16448]
	shl	r8d, 3
	mov	QWORD PTR pRxContextA$GSCopy$1$[rsp], rcx
	lea	rcx, QWORD PTR [rdx+64]
	mov	QWORD PTR blksEnd$1$[rsp], rax
	mov	eax, DWORD PTR [r9+776]

; 242  :     pTrellis[0] = ALL_INIT0;

	movdqa	xmm0, XMMWORD PTR ?ALL_INIT0@@3QBEB
	movdqa	xmm6, XMMWORD PTR ?ALL_INVERSE_ONE@@3QBEB
	movdqa	XMMWORD PTR [rbp], xmm0

; 243  :     pTrellis[1] = ALL_INIT;

	movdqa	xmm1, XMMWORD PTR ?ALL_INIT@@3QBEB
	sub	eax, 2
	or	r13d, -1				; ffffffffH
	mov	QWORD PTR fWork$1$[rsp], r11
	movdqa	XMMWORD PTR [rbp+16], xmm1

; 244  :     pTrellis[2] = ALL_INIT;

	movdqa	xmm0, XMMWORD PTR ?ALL_INIT@@3QBEB
	mov	DWORD PTR uiCrc32StorePoint$1$[rsp], eax
	mov	DWORD PTR uiBitsTotal$1$[rsp], r8d
	mov	r12d, ebx
	movdqa	XMMWORD PTR [rbp+32], xmm0

; 245  :     pTrellis[3] = ALL_INIT;

	movdqa	xmm1, XMMWORD PTR ?ALL_INIT@@3QBEB
	mov	QWORD PTR blksStart$1$[rsp], rcx
	mov	r10, rcx
	mov	QWORD PTR blkInputStart$1$[rsp], rcx
	movdqa	XMMWORD PTR [rbp+48], xmm1

; 246  : 
; 247  :     assert(&blkInputStart->isValid == blkInput);
; 248  :     while (blkInputStart->isValid == 0 && fWork)

	movzx	eax, BYTE PTR [rcx]
	mov	edi, ebx
	test	al, al
	jne	SHORT $LN3216@VitDesCRC
	npad	4
$LL33@VitDesCRC:
	movzx	eax, BYTE PTR [r11]
	test	al, al
	je	SHORT $LN3216@VitDesCRC

; 249  :         _mm_pause();

	pause
	movzx	eax, BYTE PTR [rcx]
	test	al, al
	je	SHORT $LL33@VitDesCRC
$LN3216@VitDesCRC:

; 250  : 
; 251  :     if (!fWork) return;

	movzx	eax, BYTE PTR [r11]
	test	al, al
	je	$LN2@VitDesCRC

; 252  :     blkInput += 4; // jump to data

	add	rcx, 4
	mov	QWORD PTR [rsp+168], rsi
	mov	QWORD PTR [rsp+176], r14
	mov	QWORD PTR blkInput$1$[rsp], rcx

; 253  :     
; 254  :     // viterbi decode and descramble here
; 255  :     // continue to process all input bits
; 256  :     while (uiBitsTotal)

	test	r8d, r8d
	je	$LN3215@VitDesCRC
	mov	ebx, DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51
	movzx	esi, BYTE PTR bSeed$[rsp]
	mov	r14d, DWORD PTR uiCrc32Store$[rsp]
	npad	1
$LL30@VitDesCRC:

; 257  :     {
; 258  :         if (MBitRate == 6 || MBitRate == 24 || MBitRate == 12)
; 259  :         {
; 260  :             ViterbiAdvance(pTrellis, pVITMA, blkInput[0], pVITMB, blkInput[1]);
; 261  :             blkInput += 2; // jump to data
; 262  :             i_trellis++;
; 263  :         }
; 264  :         else if (MBitRate == 9 || MBitRate == 18 || MBitRate == 36 || MBitRate == 54)
; 265  :         {
; 266  :             ViterbiAdvance(pTrellis, pVITMA, blkInput[0], pVITMB, blkInput[1]);

	movsx	eax, BYTE PTR [rcx]
	movdqa	xmm4, XMMWORD PTR ?ALL_ONE@@3QBEB
	movdqa	xmm3, XMMWORD PTR ?ALL_INVERSE_ONE@@3QBEB
	movsx	ecx, BYTE PTR [rcx+1]
	shl	eax, 3
	movdqa	xmm1, XMMWORD PTR [rbp]
	movdqa	xmm0, XMMWORD PTR [rbp+32]
	movsxd	r8, eax
	shl	ecx, 3
	movsxd	r9, ecx
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	rdx, r8
	punpcklbw xmm0, xmm0
	punpcklbw xmm1, xmm1
	add	rdx, rdx
	mov	rax, r9
	add	rax, rax
	paddb	xmm0, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[rcx+rdx*8+16]
	paddb	xmm1, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[rcx+rdx*8]
	paddb	xmm0, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[rcx+rax*8+16]
	paddb	xmm1, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[rcx+rax*8]
	mov	rax, r8
	add	rax, rax
	por	xmm0, xmm4
	pand	xmm1, xmm3
	pminub	xmm1, xmm0
	movdqa	XMMWORD PTR [rbp+64], xmm1
	movdqa	xmm2, XMMWORD PTR [rbp]
	movdqa	xmm0, XMMWORD PTR [rbp+32]
	punpckhbw xmm0, xmm0
	punpckhbw xmm2, xmm2
	paddb	xmm2, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[rcx+rax*8+32]
	mov	rax, r9
	add	rax, rax
	paddb	xmm2, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[rcx+rax*8+32]
	mov	rax, r8
	add	rax, rax
	paddb	xmm0, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[rcx+rax*8+48]
	pand	xmm2, xmm3
	mov	rax, r9
	add	rax, rax
	paddb	xmm0, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[rcx+rax*8+48]
	mov	rax, r8
	add	rax, rax
	por	xmm0, xmm4
	pminub	xmm2, xmm0
	movdqa	XMMWORD PTR [rbp+80], xmm2
	movdqa	xmm1, XMMWORD PTR [rbp+16]
	movdqa	xmm0, XMMWORD PTR [rbp+48]
	punpcklbw xmm0, xmm0
	punpcklbw xmm1, xmm1
	paddb	xmm1, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[rcx+rax*8+64]
	mov	rax, r9
	add	rax, rax
	paddb	xmm1, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[rcx+rax*8+64]
	mov	rax, r8
	add	rax, rax
	paddb	xmm0, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[rcx+rax*8+80]
	pand	xmm1, xmm3
	mov	rax, r9
	add	rax, rax
	paddb	xmm0, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[rcx+rax*8+80]
	mov	rax, r8
	add	r8, r8
	por	xmm0, xmm4
	add	rax, rax
	pminub	xmm1, xmm0
	movdqa	XMMWORD PTR [rbp+96], xmm1
	movdqa	xmm2, XMMWORD PTR [rbp+16]
	movdqa	xmm0, XMMWORD PTR [rbp+48]
	punpckhbw xmm2, xmm2
	punpckhbw xmm0, xmm0
	paddb	xmm2, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[rcx+rax*8+96]
	paddb	xmm0, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[rcx+r8*8+112]
	mov	rax, r9
	add	rax, rax
	add	r9, r9
	paddb	xmm0, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[rcx+r9*8+112]
	paddb	xmm2, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[rcx+rax*8+96]
	por	xmm0, xmm4
	pand	xmm2, xmm3

; 267  :             ViterbiAdvance(pTrellis, pVITMA, blkInput[2]);

	mov	r8, QWORD PTR blkInput$1$[rsp]
	pminub	xmm2, xmm0
	lea	r9, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR [rbp+128]
	movdqa	XMMWORD PTR [rbp+112], xmm2
	movdqa	xmm4, XMMWORD PTR ?ALL_ONE@@3QBEB
	movdqa	xmm3, XMMWORD PTR ?ALL_INVERSE_ONE@@3QBEB
	movsx	eax, BYTE PTR [r8+2]
	movdqa	xmm1, XMMWORD PTR [rbp+64]
	movdqa	xmm0, XMMWORD PTR [rbp+96]
	shl	eax, 3
	movsxd	rcx, eax
	mov	rax, rcx
	add	rax, rax
	punpcklbw xmm0, xmm0
	punpcklbw xmm1, xmm1
	paddb	xmm0, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[r9+rax*8+16]
	paddb	xmm1, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[r9+rax*8]
	mov	rax, rcx
	add	rax, rax
	por	xmm0, xmm4
	pand	xmm1, xmm3
	pminub	xmm1, xmm0
	movdqa	XMMWORD PTR [rdx], xmm1
	movdqa	xmm2, XMMWORD PTR [rbp+64]
	movdqa	xmm0, XMMWORD PTR [rbp+96]
	punpckhbw xmm0, xmm0
	punpckhbw xmm2, xmm2
	paddb	xmm2, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[r9+rax*8+32]
	mov	rax, rcx
	add	rax, rax
	paddb	xmm0, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[r9+rax*8+48]
	pand	xmm2, xmm3
	mov	rax, rcx
	add	rax, rax
	por	xmm0, xmm4
	pminub	xmm2, xmm0
	movdqa	XMMWORD PTR [rbp+144], xmm2
	movdqa	xmm1, XMMWORD PTR [rbp+80]
	movdqa	xmm0, XMMWORD PTR [rbp+112]
	punpcklbw xmm0, xmm0
	punpcklbw xmm1, xmm1
	paddb	xmm1, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[r9+rax*8+64]
	mov	rax, rcx
	add	rax, rax
	paddb	xmm0, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[r9+rax*8+80]
	pand	xmm1, xmm3
	mov	rax, rcx
	add	rcx, rcx
	add	rax, rax
	por	xmm0, xmm4
	pminub	xmm1, xmm0
	movdqa	XMMWORD PTR [rbp+160], xmm1
	movdqa	xmm2, XMMWORD PTR [rbp+80]
	movdqa	xmm0, XMMWORD PTR [rbp+112]
	punpckhbw xmm0, xmm0
	punpckhbw xmm2, xmm2
	paddb	xmm2, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[r9+rax*8+96]
	paddb	xmm0, XMMWORD PTR ?VIT_MA@@3QAY0BA@$$CBEA[r9+rcx*8+112]
	por	xmm0, xmm4
	pand	xmm2, xmm3
	pminub	xmm2, xmm0
	movdqa	XMMWORD PTR [rbp+176], xmm2

; 268  :             ViterbiAdvance(pTrellis, pVITMB, blkInput[3]);

	movsx	eax, BYTE PTR [r8+3]
	movdqa	xmm1, XMMWORD PTR [rdx]
	shl	eax, 3
	lea	rbp, QWORD PTR [rdx+64]
	movsxd	rcx, eax
	mov	QWORD PTR pTrellis$3$[rsp], rbp
	movdqa	xmm0, XMMWORD PTR [rdx+32]
	movdqa	xmm4, XMMWORD PTR ?ALL_ONE@@3QBEB
	movdqa	xmm3, XMMWORD PTR ?ALL_INVERSE_ONE@@3QBEB
	punpcklbw xmm1, xmm1
	mov	rax, rcx
	add	rax, rax
	punpcklbw xmm0, xmm0
	paddb	xmm1, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[r9+rax*8]
	paddb	xmm0, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[r9+rax*8+16]
	pand	xmm1, xmm3
	por	xmm0, xmm4
	pminub	xmm1, xmm0
	movdqa	XMMWORD PTR [rbp], xmm1
	movdqa	xmm2, XMMWORD PTR [rdx]
	movdqa	xmm0, XMMWORD PTR [rdx+32]
	mov	rax, rcx

; 269  :             blkInput += 4;
; 270  :             i_trellis += 3;

	add	edi, 3
	add	r8, 4
	add	rax, rax
	mov	QWORD PTR blkInput$1$[rsp], r8
	mov	DWORD PTR i_trellis$1$[rsp], edi
	punpckhbw xmm0, xmm0
	punpckhbw xmm2, xmm2
	paddb	xmm2, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[r9+rax*8+32]
	mov	rax, rcx
	add	rax, rax
	pand	xmm2, xmm3
	paddb	xmm0, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[r9+rax*8+48]
	mov	rax, rcx
	por	xmm0, xmm4
	add	rax, rax
	pminub	xmm2, xmm0
	movdqa	XMMWORD PTR [rdx+80], xmm2
	movdqa	xmm1, XMMWORD PTR [rdx+16]
	movdqa	xmm0, XMMWORD PTR [rdx+48]
	punpcklbw xmm0, xmm0
	punpcklbw xmm1, xmm1
	paddb	xmm1, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[r9+rax*8+64]
	mov	rax, rcx
	add	rax, rax
	paddb	xmm0, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[r9+rax*8+80]
	pand	xmm1, xmm3
	mov	rax, rcx
	add	rcx, rcx
	add	rax, rax
	por	xmm0, xmm4
	pminub	xmm1, xmm0
	movdqa	XMMWORD PTR [rdx+96], xmm1
	movdqa	xmm2, XMMWORD PTR [rdx+16]
	movdqa	xmm0, XMMWORD PTR [rdx+48]
	punpckhbw xmm2, xmm2
	punpckhbw xmm0, xmm0
	paddb	xmm2, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[r9+rax*8+96]
	paddb	xmm0, XMMWORD PTR ?VIT_MB@@3QAY0BA@$$CBEA[r9+rcx*8+112]
	pand	xmm2, xmm3
	por	xmm0, xmm4
	pminub	xmm2, xmm0
	movdqa	XMMWORD PTR [rdx+112], xmm2

; 271  :         }
; 272  :         else if (MBitRate == 48)
; 273  :         {
; 274  :             ViterbiAdvance(pTrellis, pVITMA, blkInput[0], pVITMB, blkInput[1]);
; 275  :             ViterbiAdvance(pTrellis, pVITMA, blkInput[2]);
; 276  :             blkInput += 3;
; 277  :             i_trellis += 2;
; 278  :         }
; 279  : 
; 280  :         // Dump trellis
; 281  :         //DUMP_TRELLIS (pTrellis);
; 282  : 
; 283  :         // Normalize
; 284  :         if ((i_trellis & NOR_MASK_) == 0 )

	test	dil, 3
	jne	$LN22@VitDesCRC

; 285  :         {
; 286  :             // normalization
; 287  :             // find the smallest component and extract it from all states
; 288  :   
; 289  :             rub0 = smin (pTrellis[0], pTrellis[1] );

	movdqa	xmm3, XMMWORD PTR [rbp]

; 290  :             rub1 = smin (pTrellis[2], pTrellis[3] );

	movdqa	xmm0, XMMWORD PTR [rbp+32]
	movdqa	xmm1, xmm3
	pminub	xmm0, XMMWORD PTR [rbp+48]
	pminub	xmm1, XMMWORD PTR [rbp+16]

; 291  :             rub2 = smin (rub0, rub1);

	pminub	xmm1, xmm0

; 292  : 
; 293  :             rub3 = hmin (rub2);

	pshufd	xmm2, xmm1, 78				; 0000004eH
	pminub	xmm2, xmm1
	pshufd	xmm0, xmm2, 177				; 000000b1H
	pminub	xmm2, xmm0
	punpcklbw xmm2, xmm2
	punpcklbw xmm2, xmm2
	pshufd	xmm0, xmm2, 78				; 0000004eH
	pminub	xmm2, xmm0
	pshufd	xmm0, xmm2, 177				; 000000b1H
	pminub	xmm2, xmm0

; 294  : 
; 295  :             // make sure to clear the marker bit
; 296  :             rub3 = and  (rub3, ALLINVONE );

	pand	xmm2, xmm6

; 297  :             
; 298  :             // normalize
; 299  :             pTrellis[0] = sub ( pTrellis[0], rub3);

	psubb	xmm3, xmm2
	movdqa	XMMWORD PTR [rbp], xmm3

; 300  :             pTrellis[1] = sub ( pTrellis[1], rub3);

	movdqa	xmm0, XMMWORD PTR [rbp+16]
	psubb	xmm0, xmm2
	movdqa	XMMWORD PTR [rbp+16], xmm0

; 301  :             pTrellis[2] = sub ( pTrellis[2], rub3);

	movdqa	xmm1, XMMWORD PTR [rbp+32]
	psubb	xmm1, xmm2
	movdqa	XMMWORD PTR [rbp+32], xmm1

; 302  :             pTrellis[3] = sub ( pTrellis[3], rub3);     

	movdqa	xmm0, XMMWORD PTR [rbp+48]
	psubb	xmm0, xmm2
	movdqa	XMMWORD PTR [rbp+48], xmm0

; 303  :   
; 304  :             // here I need also check if we need to load a new descriptor
; 305  :             if (NeedNewDescriptor<MBitRate>(i_trellis))

	cmp	edi, 72					; 00000048H
	je	SHORT $LN2302@VitDesCRC
	cmp	edi, 144				; 00000090H
	jne	SHORT $LN22@VitDesCRC
$LN2302@VitDesCRC:

; 306  :             {
; 307  :                 // read a new descriptor
; 308  :                 blkInputStart->isValid = 0;

	mov	BYTE PTR [r10], 0

; 309  :                 blkInputStart += 1;

	sub	r10, -128				; ffffffffffffff80H

; 310  :                 if ( blkInputStart == blksEnd )

	cmp	r10, QWORD PTR blksEnd$1$[rsp]
	cmove	r10, QWORD PTR blksStart$1$[rsp]
	mov	QWORD PTR blkInputStart$1$[rsp], r10

; 311  :                     blkInputStart = blksStart;
; 312  :                 blkInput = (char *)blkInputStart;
; 313  : 
; 314  :                 // wait ready
; 315  :                 assert(&blkInputStart->isValid == blkInput);
; 316  :                 while (blkInputStart->isValid == 0 && fWork)

	movzx	eax, BYTE PTR [r10]
	test	al, al
	jne	SHORT $LN3217@VitDesCRC
	npad	6
$LL20@VitDesCRC:
	movzx	eax, BYTE PTR [r11]
	test	al, al
	je	SHORT $LN3217@VitDesCRC

; 317  :                     _mm_pause();

	pause
	movzx	eax, BYTE PTR [r10]
	test	al, al
	je	SHORT $LL20@VitDesCRC
$LN3217@VitDesCRC:

; 318  : 
; 319  :                 if (!fWork) return;

	movzx	eax, BYTE PTR [r11]
	test	al, al
	je	$LN3220@VitDesCRC

; 320  :                 blkInput += 4; // jump to data

	mov	ebx, DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51
	lea	rax, QWORD PTR [r10+4]
	mov	QWORD PTR blkInput$1$[rsp], rax
$LN22@VitDesCRC:

; 321  :             }
; 322  :         }
; 323  :         
; 324  :         // Traceback 
; 325  :         // We should first skip TB_DEPTH_VITAS bits and 
; 326  :         // TB_OUTPUT_VITAS is acutal bits we can output
; 327  :         if ( i_trellis >= TB_DEPTH_ + TB_OUTPUT_ + TB_PREFIX )

	cmp	edi, 150				; 00000096H
	jl	$LN3218@VitDesCRC

; 328  :         {
; 329  :             // track back
; 330  :             // we need to find the minimal state and index of the state
; 331  : 
; 332  :             // do normalization first
; 333  :     
; 334  :             rub0 = smin (pTrellis[0], pTrellis[1] );

	movdqa	xmm3, XMMWORD PTR [rbp]

; 335  :             rub1 = smin (pTrellis[2], pTrellis[3] );

	movdqa	xmm0, XMMWORD PTR [rbp+32]
	movdqa	xmm1, xmm3
	pminub	xmm0, XMMWORD PTR [rbp+48]
	pminub	xmm1, XMMWORD PTR [rbp+16]

; 336  :             rub2 = smin (rub0, rub1);

	pminub	xmm1, xmm0

; 337  : 
; 338  :             rub3 = hmin (rub2);

	pshufd	xmm2, xmm1, 78				; 0000004eH
	pminub	xmm2, xmm1
	pshufd	xmm0, xmm2, 177				; 000000b1H
	pminub	xmm2, xmm0
	punpcklbw xmm2, xmm2
	punpcklbw xmm2, xmm2
	pshufd	xmm0, xmm2, 78				; 0000004eH
	pminub	xmm2, xmm0
	pshufd	xmm0, xmm2, 177				; 000000b1H
	pminub	xmm2, xmm0

; 339  :             rub3 = and  (rub3, ALLINVONE );

	pand	xmm2, xmm6

; 340  :         
; 341  :             // normalize
; 342  :             pTrellis[0] = sub ( pTrellis[0], rub3);

	psubb	xmm3, xmm2
	movdqa	XMMWORD PTR [rbp], xmm3

; 343  :             pTrellis[1] = sub ( pTrellis[1], rub3);

	movdqa	xmm0, XMMWORD PTR [rbp+16]
	psubb	xmm0, xmm2
	movdqa	XMMWORD PTR [rbp+16], xmm0

; 344  :             pTrellis[2] = sub ( pTrellis[2], rub3);

	movdqa	xmm1, XMMWORD PTR [rbp+32]
	psubb	xmm1, xmm2
	movdqa	XMMWORD PTR [rbp+32], xmm1

; 345  :             pTrellis[3] = sub ( pTrellis[3], rub3);        

	movdqa	xmm0, XMMWORD PTR [rbp+48]
	psubb	xmm0, xmm2
	movdqa	XMMWORD PTR [rbp+48], xmm0

; 346  :     
; 347  :             
; 348  :             // rub3 has the minimal value, we need to find the index
; 349  :             // the algorithm to find the right index is to embed the index at the least
; 350  :             // significant bits of state value, then we just find the minimal value
; 351  : 
; 352  : 
; 353  :             rub0 = INDEXES[0];

	movdqa	xmm3, XMMWORD PTR ?INDEXES@@3QAY0BA@$$CBEA

; 354  :             rub1 = pTrellis[0];

	movdqa	xmm1, XMMWORD PTR [rbp]

; 355  : 
; 356  :             rus2 = (vus)interleave_low  ( rub0, rub1 );
; 357  :             rus3 = (vus)interleave_high ( rub0, rub1 );
; 358  :             rus4 = smin ( rus2, rus3);

	movdqa	xmm4, XMMWORD PTR ?mid@?1???$middle@Uvs@@@vector128_consts@@SA?BUvs@@XZ@4QBGB
	movdqa	xmm2, xmm3
	punpcklbw xmm2, xmm1
	punpckhbw xmm3, xmm1
	test	bl, 1
	jne	SHORT $LN3214@VitDesCRC
	movdqa	xmm1, xmm4
	or	ebx, 1
	movdqa	XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B, xmm1
	mov	DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51, ebx
	jmp	SHORT $LN2553@VitDesCRC
$LN3214@VitDesCRC:
	movdqa	xmm1, XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B
$LN2553@VitDesCRC:

; 359  : 
; 360  :             rub0 = INDEXES[1];

	movdqa	xmm5, XMMWORD PTR ?INDEXES@@3QAY0BA@$$CBEA+16

; 361  :             rub1 = pTrellis[1];

	movdqa	xmm0, XMMWORD PTR [rbp+16]
	pxor	xmm3, xmm1
	pxor	xmm2, xmm1
	pminsw	xmm2, xmm3

; 362  :             rus2 = (vus)interleave_low  ( rub0, rub1 );

	movdqa	xmm3, xmm5

; 363  :             rus3 = (vus)interleave_high ( rub0, rub1 );

	punpckhbw xmm5, xmm0
	punpcklbw xmm3, xmm0
	pxor	xmm2, xmm1

; 364  :             rus5 = smin (rus2, rus3);

	test	bl, 1
	jne	SHORT $LN2634@VitDesCRC
	movdqa	xmm1, xmm4
	or	ebx, 1
	movdqa	XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B, xmm1
	mov	DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51, ebx
$LN2634@VitDesCRC:
	pxor	xmm3, xmm1
	pxor	xmm5, xmm1
	pminsw	xmm3, xmm5
	pxor	xmm3, xmm1

; 365  :             
; 366  :             rus4 = smin (rus4, rus5);

	test	bl, 1
	jne	SHORT $LN2683@VitDesCRC
	movdqa	xmm1, xmm4
	or	ebx, 1
	movdqa	XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B, xmm1
	mov	DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51, ebx
$LN2683@VitDesCRC:

; 367  : 
; 368  :             rub0 = INDEXES[2];

	movdqa	xmm5, XMMWORD PTR ?INDEXES@@3QAY0BA@$$CBEA+32

; 369  :             rub1 = pTrellis[2];

	movdqa	xmm0, XMMWORD PTR [rbp+32]
	pxor	xmm3, xmm1
	pxor	xmm2, xmm1
	pminsw	xmm2, xmm3

; 370  :             rus2 = (vus)interleave_low  ( rub0, rub1 );

	movdqa	xmm3, xmm5

; 371  :             rus3 = (vus)interleave_high ( rub0, rub1 );

	punpckhbw xmm5, xmm0
	punpcklbw xmm3, xmm0
	pxor	xmm2, xmm1

; 372  :             rus6 = smin (rus2, rus3);

	test	bl, 1
	jne	SHORT $LN2764@VitDesCRC
	movdqa	xmm1, xmm4
	or	ebx, 1
	movdqa	XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B, xmm1
	mov	DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51, ebx
$LN2764@VitDesCRC:
	pxor	xmm3, xmm1
	pxor	xmm5, xmm1
	pminsw	xmm3, xmm5
	pxor	xmm3, xmm1

; 373  :             
; 374  :             rus4 = smin (rus4, rus6);

	test	bl, 1
	jne	SHORT $LN2813@VitDesCRC
	movdqa	xmm1, xmm4
	or	ebx, 1
	movdqa	XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B, xmm1
	mov	DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51, ebx
$LN2813@VitDesCRC:

; 375  : 
; 376  :             rub0 = INDEXES[3];

	movdqa	xmm5, XMMWORD PTR ?INDEXES@@3QAY0BA@$$CBEA+48

; 377  :             rub1 = pTrellis[3];

	movdqa	xmm0, XMMWORD PTR [rbp+48]
	pxor	xmm3, xmm1
	pxor	xmm2, xmm1
	pminsw	xmm2, xmm3

; 378  :             rus2 = (vus)interleave_low  ( rub0, rub1 );

	movdqa	xmm3, xmm5

; 379  :             rus3 = (vus)interleave_high ( rub0, rub1 );

	punpckhbw xmm5, xmm0
	punpcklbw xmm3, xmm0
	pxor	xmm2, xmm1

; 380  :             rus7 = smin (rus2, rus3);

	test	bl, 1
	jne	SHORT $LN2894@VitDesCRC
	movdqa	xmm1, xmm4
	or	ebx, 1
	movdqa	XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B, xmm1
	mov	DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51, ebx
$LN2894@VitDesCRC:
	pxor	xmm3, xmm1
	pxor	xmm5, xmm1
	pminsw	xmm3, xmm5
	pxor	xmm3, xmm1

; 381  :             
; 382  :             rus4 = smin (rus4, rus7);

	test	bl, 1
	jne	SHORT $LN2943@VitDesCRC
	movdqa	xmm1, xmm4
	or	ebx, 1
	movdqa	XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B, xmm1
	mov	DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51, ebx
$LN2943@VitDesCRC:
	pxor	xmm2, xmm1
	pxor	xmm3, xmm1
	pminsw	xmm2, xmm3
	pxor	xmm2, xmm1

; 383  : 
; 384  :             // now rus4 contains the minimal 8 
; 385  :             rus0 = hmin (rus4);

	pshufd	xmm0, xmm2, 78				; 0000004eH
	test	bl, 1
	jne	SHORT $LN3010@VitDesCRC
	movdqa	xmm1, xmm4
	or	ebx, 1
	movdqa	XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B, xmm1
	mov	DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51, ebx
$LN3010@VitDesCRC:
	pxor	xmm2, xmm1
	pxor	xmm0, xmm1
	pminsw	xmm2, xmm0
	pxor	xmm2, xmm1
	pshufd	xmm0, xmm2, 177				; 000000b1H
	test	bl, 1
	jne	SHORT $LN3071@VitDesCRC
	movdqa	xmm1, xmm4
	or	ebx, 1
	movdqa	XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B, xmm1
	mov	DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51, ebx
$LN3071@VitDesCRC:
	pxor	xmm2, xmm1
	pxor	xmm0, xmm1
	pminsw	xmm2, xmm0
	pxor	xmm2, xmm1
	pshuflw	xmm0, xmm2, 177				; 000000b1H
	pshufd	xmm3, xmm0, 17
	test	bl, 1
	jne	SHORT $LN3140@VitDesCRC
	movdqa	xmm1, xmm4
	or	ebx, 1
	movdqa	XMMWORD PTR ?mid@?1??smin@@YA?AUvus@@AEBU2@0@Z@4Uvs@@B, xmm1
	mov	DWORD PTR ??_B?1??smin@@YA?AUvus@@AEBU1@0@Z@51, ebx
$LN3140@VitDesCRC:
	pxor	xmm2, xmm1
	pxor	xmm3, xmm1

; 386  : 
; 387  :             // now the first word contains the index and value
; 388  :             // index: bit [7:2]; 
; 389  :             // value: bit [15:8]
; 390  :             i_minpos = extract<0>(rus0); 
; 391  : 
; 392  :             // now we can trace back ...
; 393  :             pTraceBk = pTrellis;

	mov	r11, rbp
	mov	r8d, 12
	pminsw	xmm2, xmm3
	pxor	xmm2, xmm1
	pextrw	r10d, xmm2, 0

; 394  : 
; 395  :             // first part - trace back without output
; 396  :             i_minpos = (i_minpos >> 2) & 0x3F; // index 6:0

	shr	r10d, 2
	and	r10d, 63				; 0000003fH
	npad	3
$LL16@VitDesCRC:

; 397  :             for ( i = 0; i < TB_DEPTH_; i++)
; 398  :             {
; 399  :                 pTraceBk -= 4;
; 400  :                 i_minpos = (i_minpos >> 1) & 0x3F;

	sar	r10d, 1

; 401  :                 i_tpos = ((char*) pTraceBk)[i_minpos] ;
; 402  :                 i_minpos |= (i_tpos & 1) << 6;  // now i_minpos 6:0 is the new index

	sub	r11, 384				; 00000180H
	and	r10d, 63				; 0000003fH
	movsxd	rax, r10d
	movsx	ecx, BYTE PTR [rax+r11+320]
	shl	ecx, 6
	or	ecx, r10d
	sar	ecx, 1
	and	ecx, 63					; 0000003fH
	movsxd	rax, ecx
	movsx	edx, BYTE PTR [rax+r11+256]
	shl	edx, 6
	or	edx, ecx
	sar	edx, 1
	and	edx, 63					; 0000003fH
	movsxd	rax, edx
	movsx	ecx, BYTE PTR [rax+r11+192]
	shl	ecx, 6
	or	ecx, edx
	sar	ecx, 1
	and	ecx, 63					; 0000003fH
	movsxd	rax, ecx
	movsx	edx, BYTE PTR [rax+r11+128]
	shl	edx, 6
	or	edx, ecx
	sar	edx, 1
	and	edx, 63					; 0000003fH
	movsxd	rax, edx
	movsx	r10d, BYTE PTR [rax+r11+64]
	shl	r10d, 6
	or	r10d, edx
	sar	r10d, 1
	and	r10d, 63				; 0000003fH
	movsxd	rax, r10d
	movsx	ecx, BYTE PTR [rax+r11]
	and	ecx, 1
	shl	ecx, 6
	or	r10d, ecx
	sub	r8, 1
	jne	$LL16@VitDesCRC

; 403  :             }
; 404  : 
; 405  :             // second part - trace back with output
; 406  :             pbVitOutput += (TB_OUTPUT_ >> 3);

	mov	rax, QWORD PTR pbVitOutput$1$[rsp]
	lea	ebp, QWORD PTR [r8+9]
	add	rax, 9
	mov	QWORD PTR pbVitOutput$1$[rsp], rax

; 407  :             pVTOutput = (unsigned char*)pbVitOutput;

	mov	rdi, rax
	npad	2
$LL13@VitDesCRC:

; 408  :             
; 409  :             for ( i = 0; i < TB_OUTPUT_ >> 3; i++)
; 410  :             {
; 411  :                 for ( j = 0; j < 8; j++ )
; 412  :                 {
; 413  :                     outchar = outchar << 1;
; 414  :                     outchar |= (i_minpos >> 6) & 1;

	mov	edx, r10d

; 415  : 
; 416  :                     // next bit
; 417  :                     pTraceBk -= 4;
; 418  :                     i_minpos = (i_minpos >> 1) & 0x3F;

	sar	r10d, 1
	and	r10d, 63				; 0000003fH
	sar	edx, 6

; 419  :                     i_tpos = ((char*) pTraceBk)[i_minpos] ;
; 420  :                     i_minpos |= (i_tpos & 1) << 6;  // now i_minpos 6:0 is the new index

	movsxd	rax, r10d
	and	dl, 1
	movsx	ecx, BYTE PTR [rax+r11-64]
	add	dl, dl
	and	ecx, 1
	shl	ecx, 6
	or	r10d, ecx
	mov	r8d, r10d
	sar	r10d, 1
	and	r10d, 63				; 0000003fH
	sar	r8d, 6
	movsxd	rax, r10d
	and	r8b, 1
	movsx	ecx, BYTE PTR [rax+r11-128]
	or	r8b, dl
	and	ecx, 1
	add	r8b, r8b
	shl	ecx, 6
	or	r10d, ecx
	mov	edx, r10d
	sar	r10d, 1
	and	r10d, 63				; 0000003fH
	sar	edx, 6
	movsxd	rax, r10d
	and	dl, 1
	movsx	ecx, BYTE PTR [rax+r11-192]
	or	dl, r8b
	and	ecx, 1
	add	dl, dl
	shl	ecx, 6
	or	r10d, ecx
	mov	r8d, r10d
	sar	r10d, 1
	and	r10d, 63				; 0000003fH
	sar	r8d, 6
	movsxd	rax, r10d
	and	r8b, 1
	movsx	ecx, BYTE PTR [rax+r11-256]
	or	r8b, dl
	and	ecx, 1
	add	r8b, r8b
	shl	ecx, 6
	or	r10d, ecx
	mov	edx, r10d
	sar	r10d, 1
	and	r10d, 63				; 0000003fH
	sar	edx, 6
	movsxd	rax, r10d
	and	dl, 1
	movsx	ecx, BYTE PTR [rax+r11-320]
	or	dl, r8b
	and	ecx, 1
	add	dl, dl
	shl	ecx, 6
	or	r10d, ecx
	mov	r8d, r10d
	sar	r10d, 1
	and	r10d, 63				; 0000003fH
	sar	r8d, 6
	movsxd	rax, r10d
	and	r8b, 1
	movsx	ecx, BYTE PTR [rax+r11-384]
	or	r8b, dl
	and	ecx, 1
	add	r8b, r8b
	shl	ecx, 6
	or	r10d, ecx
	mov	r9d, r10d
	sar	r10d, 1
	sar	r9d, 6
	and	r10d, 63				; 0000003fH
	and	r9b, 1
	movsxd	rax, r10d
	movsx	ecx, BYTE PTR [rax+r11-448]
	or	r9b, r8b
	and	ecx, 1
	shl	ecx, 6
	or	r10d, ecx
	add	r9b, r9b

; 421  :                 }
; 422  : 
; 423  :                 pVTOutput --;

	dec	rdi
	mov	edx, r10d
	sar	r10d, 1
	sub	r11, 512				; 00000200H
	and	r10d, 63				; 0000003fH
	sar	edx, 6
	movsxd	rax, r10d
	and	dl, 1
	movsx	ecx, BYTE PTR [rax+r11]
	or	dl, r9b
	and	ecx, 1

; 424  :                 * pVTOutput = outchar;

	mov	BYTE PTR [rdi], dl
	shl	ecx, 6
	or	r10d, ecx
	sub	rbp, 1
	jne	$LL13@VitDesCRC
	mov	rbp, QWORD PTR pTrellis$3$[rsp]

; 425  :                 
; 426  :                 outchar = 0;
; 427  :             }
; 428  : 
; 429  :             // We need to do descramble and CRC here
; 430  :             for ( i = 0; i < TB_OUTPUT_ >> 3; i++)

	xor	edx, edx
	lea	r9, OFFSET FLAT:__ImageBase
$LL7@VitDesCRC:

; 431  :             {
; 432  :                 // first two bytes are seed
; 433  :                 if ( uiBytesOutput < 2)

	cmp	r12d, 2
	jae	SHORT $LN4@VitDesCRC

; 434  :                 {
; 435  :                     uiBytesOutput += 2;
; 436  :                     bSeed = (* (pVTOutput+1)) >> 1;

	mov	sil, BYTE PTR [rdi+1]
	add	r12d, 2

; 437  :                     pVTOutput += 2;

	add	rdi, 2
	shr	sil, 1

; 438  :                     i += 2; // as if we start from the 3rd char

	add	edx, 2
$LN4@VitDesCRC:

; 439  :                 }
; 440  :                 
; 441  :                 // scramble
; 442  :                 bSeed = SCRAMBLE_11A_LUT[bSeed];

	movzx	eax, sil

; 443  :                 *pbOutput = (*pVTOutput) ^ bSeed;
; 444  :                 bSeed >>= 1;
; 445  : 
; 446  :                 pVTOutput ++;
; 447  :                 uiBytesOutput ++;
; 448  :             
; 449  :                 // compute crc32
; 450  :                 CalcCRC32Incremental(*pbOutput, &uiCrc32);

	movzx	ecx, r13b
	inc	r12d
	mov	sil, BYTE PTR SCRAMBLE_11A_LUT[rax+r9]
	inc	rdi

; 451  :                 //fprintf(stderr, "CRC %d:\t0x%08X\n", (uiBytesOutput)-3, uiCrc32);
; 452  : 
; 453  :                 pbOutput ++;

	inc	r15
	movzx	eax, sil
	shr	sil, 1
	xor	al, BYTE PTR [rdi-1]
	mov	BYTE PTR [r15-1], al
	movzx	eax, al
	xor	rcx, rax
	mov	eax, r13d
	mov	r13d, DWORD PTR gc_CRC32LUT[r9+rcx*4]
	shr	eax, 8
	xor	r13d, eax

; 454  :                 
; 455  :                 if ( uiBytesOutput == uiCrc32StorePoint )

	cmp	r12d, DWORD PTR uiCrc32StorePoint$1$[rsp]
	cmove	r14d, r13d
	inc	edx
	cmp	edx, 9
	jl	SHORT $LL7@VitDesCRC

; 456  :                 {
; 457  :                     uiCrc32Store = uiCrc32;
; 458  :                 }
; 459  :             }
; 460  :                     
; 461  :             uiBitsTotal -= TB_OUTPUT_;

	mov	eax, DWORD PTR uiBitsTotal$1$[rsp]

; 462  :             i_trellis   -= TB_OUTPUT_;

	mov	edi, DWORD PTR i_trellis$1$[rsp]
	mov	r10, QWORD PTR blkInputStart$1$[rsp]
	mov	r11, QWORD PTR fWork$1$[rsp]
	add	eax, -72				; ffffffb8H
	sub	edi, 72					; 00000048H
	mov	DWORD PTR uiBitsTotal$1$[rsp], eax
	jmp	SHORT $LN17@VitDesCRC
$LN3218@VitDesCRC:

; 456  :                 {
; 457  :                     uiCrc32Store = uiCrc32;
; 458  :                 }
; 459  :             }
; 460  :                     
; 461  :             uiBitsTotal -= TB_OUTPUT_;

	mov	eax, DWORD PTR uiBitsTotal$1$[rsp]
$LN17@VitDesCRC:

; 253  :     
; 254  :     // viterbi decode and descramble here
; 255  :     // continue to process all input bits
; 256  :     while (uiBitsTotal)

	mov	rcx, QWORD PTR blkInput$1$[rsp]
	test	eax, eax
	jne	$LL30@VitDesCRC
	mov	r9, QWORD PTR pRxContextA$GSCopy$1$[rsp]
	jmp	SHORT $LN29@VitDesCRC
$LN3215@VitDesCRC:
	mov	r14d, DWORD PTR uiCrc32Store$[rsp]
$LN29@VitDesCRC:

; 463  :         }                
; 464  :     }
; 465  : 
; 466  :     uiCrc32 = *(DWORD *)
; 467  :         (pRxContextA->pbVitFrameOutput + (pRxContextA->uiVitFrameLen - 4));

	mov	eax, DWORD PTR [r9+776]

; 468  : 
; 469  :     if (*(DWORD *)(pRxContextA->pbVitFrameOutput
; 470  :             + (pRxContextA->uiVitFrameLen - 4)) == ~uiCrc32Store)

	mov	eax, DWORD PTR [r9+776]
	mov	rdx, QWORD PTR [r9+784]
	sub	eax, 4
	not	r14d
	cmp	DWORD PTR [rax+rdx], r14d
	mov	eax, 0
	sete	al
	mov	DWORD PTR [r9+764], eax
$LN3220@VitDesCRC:
	mov	rsi, QWORD PTR [rsp+168]
	mov	r14, QWORD PTR [rsp+176]
$LN2@VitDesCRC:

; 471  :     {
; 472  :         pRxContextA->bCRCCorrect = TRUE;
; 473  :     }
; 474  :     else
; 475  :     {
; 476  :     	// KdPrint(("[%08x!=%08x] ", uiCrc32, ~uiCrc32Store));
; 477  :         pRxContextA->bCRCCorrect = FALSE;
; 478  :     }
; 479  : }

	mov	rbx, QWORD PTR [rsp+184]
	movaps	xmm6, XMMWORD PTR [rsp+96]
	add	rsp, 112				; 00000070H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z ENDP ; VitDesCRC<18,3,72,72,VB<96,128> >
_TEXT	ENDS
PUBLIC	?VitDesCRC18@@YAXPEAU_BB11A_RX_CONTEXT@@@Z	; VitDesCRC18
; Function compile flags: /Ogtpy
; File c:\sorasdk1.7\src\bb\dot11a\dot11\arx_vdc18.c
;	COMDAT ?VitDesCRC18@@YAXPEAU_BB11A_RX_CONTEXT@@@Z
_TEXT	SEGMENT
pRxContextA$ = 8
?VitDesCRC18@@YAXPEAU_BB11A_RX_CONTEXT@@@Z PROC		; VitDesCRC18, COMDAT

; 12   :     VitDesCRC<18, NOR_MASK, TB_DEPTH, TB_OUTPUT>
; 13   :         (pRxContextA, pRxContextA->rxFifos->vb2);

	mov	rdx, QWORD PTR [rcx+792]

; 14   : }

	jmp	??$VitDesCRC@$0BC@$02$0EI@$0EI@U?$VB@$0GA@$0IA@@@@@YAXPEAU_BB11A_RX_CONTEXT@@AEAU?$VB@$0GA@$0IA@@@@Z ; VitDesCRC<18,3,72,72,VB<96,128> >
?VitDesCRC18@@YAXPEAU_BB11A_RX_CONTEXT@@@Z ENDP		; VitDesCRC18
END
